# Derive Macro

The `derive` macro is a powerful feature in Rust that allows you to automatically implement certain traits for your custom types. This can save you a lot of boilerplate code and make your code more concise and readable.

The following traits can be derived automatically:

- `Debug`: Provides a human-readable representation of the struct.
- `Clone`: Allows cloning of the struct.
- `PartialEq`: Allows comparison of the struct for equality.
- `Eq`: Allows comparison of the struct for equality.
- `Hash`: Allows hashing of the struct.

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct MyStruct {
    field1: String,
    field2: i32,
}
```

## How to derive?

Using `Clone` as an example, how it works behind the scenes:

When you derive `Clone` for a struct, Rust generates a `clone` method that creates a new instance of the struct by copying each field. This is done using the `clone` method of each field, which is automatically generated by the `Clone` trait for primitive types like `i32` and `String`.

## What's the difference between `PartialEq` and `Eq`?

```rust
/// The primary difference to [`PartialEq`] is the additional requirement for reflexivity. A type
/// that implements [`PartialEq`] guarantees that for all `a`, `b` and `c`:
///
/// - symmetric: `a == b` implies `b == a` and `a != b` implies `!(a == b)`
/// - transitive: `a == b` and `b == c` implies `a == c`
///
/// `Eq`, which builds on top of [`PartialEq`] also implies:
///
/// - reflexive: `a == a`
```

floating point type like f32 and f64, doesn't implement `Eq` because they are not reflexive. This is because floating point can be NaN (Not a Number), which is not equal to itself.
